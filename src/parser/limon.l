%{

#include <y.tab.h>  // Header generated by from limon.y
#include <stdlib.h>



/* External variables and functions */
void yyerror(char const *); // Error function defined in limon.y
extern int line; // defined in limon.y

/* Internal variables and functions */
static void strcpy_with_alloc(char **dest, char *src);
void set_scan_string(const char *str); // This is call from limon.y

%}

%x COMMENT

%%
 /* multi-character keywords and operators */
"def"            return DEF;
">="             return GEQ;
"<="             return LEQ;
"=="             return EQ;
"!="             return NEQ;
"+="             return PLUSEQ;
"-="             return MINEQ;
"*="             return MULEQ;
"/="             return DIVEQ;
"%="             return REMEQ;
"&="             return ANDEQ;
"|="             return OREQ;
"print"          return PRINT; // TODO: To be implemented in standard library
"scan"           return SCAN; // TODO: To be implemented in standard library
"__sizeof__"     return SIZEOF;
"__2str__"       return TOSTR;
"__2char__"      return TOCHAR;
"__2int__"       return TOINT;
"__2float__"     return TOFLOAT;
"while"          return WHILE;
"null"           return NULLTOK;
"run"            return RUN; /* Don't abstract this, it evaluates the file in the current environment.*/
"error"          return ERROR; /* Don't abstract this, it should get filename and line information where it is invoked.*/
"__valuetype__"  return VALTYPE;
"__gensym__"     return GENSYM;
"__same__"       return SAME;
"__make_array__" return MAKEARR;
"__array_get__"  return ARRGET;
"__array_set__"  return ARRSET;
"__string_get__" return STRGET;
"__string_set__" return STRSET;

"true"  { yylval.bVal = true;
          return BOOL; }

"false" { yylval.bVal = false;
          return BOOL; }

 /* single character keywords and operators */
[()[\]{}=@?:+\-*/%<>&\|!#]    return *yytext;

 /* string */
\"(\\.|[^\\\"])*\"       { strcpy_with_alloc(&yylval.sVal, yytext);
                          return STRING; }

 /* character */
\'(\\.|[^\\\'])\'          { strcpy_with_alloc(&yylval.sVal, yytext);
                          return CHAR; }

 /* integer */
[0-9]+  { strcpy_with_alloc(&yylval.sVal, yytext);
          return INT; }

 /* binary integer */
0b[01]+  { strcpy_with_alloc(&yylval.sVal, yytext);
           return BIN; }

 /* hexadecimal integer */
0x[0-9A-Fa-f]+  { strcpy_with_alloc(&yylval.sVal, yytext);
                  return HEX; }

 /* float */
[0-9]*\.[0-9]+  { strcpy_with_alloc(&yylval.sVal, yytext);
                  return FLOAT; }

 /* float with precision */
[0-9]*\.[0-9]+(p|P)[1-9][0-9]*  { strcpy_with_alloc(&yylval.sVal, yytext);
                                  return FLOATP; }

 /* binary float */
0b[01]*\.[01]+  { strcpy_with_alloc(&yylval.sVal, yytext);
                  return BFLOAT; }

 /* binary float with precision */
0b[01]*\.[01]+(p|P)[1-9][0-9]*  { strcpy_with_alloc(&yylval.sVal, yytext);
                                  return BFLOATP; }

 /* hexadecimal float */
0x[0-9A-Fa-f]*\.[0-9A-Fa-f]+    { strcpy_with_alloc(&yylval.sVal, yytext);
                                  return XFLOAT; }

 /* hexadecimal float with precision */
0x[0-9A-Fa-f]*\.[0-9A-Fa-f]+(p|P)[1-9][0-9]*    { strcpy_with_alloc(&yylval.sVal, yytext);
                                                  return XFLOATP; }

 /* identifier */
[A-Za-z_][A-Za-z0-9_]*  { strcpy_with_alloc(&yylval.sVal, yytext);
                          return VAR; }

 /* symbol */
:[A-Za-z_][A-Za-z0-9_]* { strcpy_with_alloc(&yylval.sVal, yytext);
                          return SYM; }


 /* comment block */
"/*"      BEGIN(COMMENT);

<COMMENT>[^*\n]*        /* eat anything that's not a '*' */
<COMMENT>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<COMMENT>\n             line++;
<COMMENT>"*"+"/"        BEGIN(INITIAL);

 /* One line comment */
"//"[^\n]*+\n    line++;

 /* counting line number */
\n      line++;

 /* ignored whitespace characters */
[ \t]+  ;

.       { char str[64];
          sprintf(str, "Unknown character: '%c'. Ignoring.", *yytext);
          yyerror(str); }


%%


static void strcpy_with_alloc(char **dest, char *src) {
  *dest = new char[strlen(src) + 1];
  strcpy(*dest, src);
}

void set_scan_string(const char *str) {
  yy_scan_string(str);
}

/* Needed by Lex */

// Terminate scanner after EOF by returning 1
int yywrap(void) { return 1; }


